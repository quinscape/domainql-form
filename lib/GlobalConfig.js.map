{"version":3,"sources":["../src/GlobalConfig.js"],"names":["resolveStaticRenderer","renderers","labelLookup","staticRenderers","noneText","matchesRule","rule","currentType","currentKind","currentFieldType","currentName","type","fieldType","kind","name","undefined","validateRule","index","Error","JSON","stringify","isEqual","ruleA","ruleB","typeA","kindA","fieldTypeA","nameA","typeB","kindB","fieldTypeB","nameB","validateRules","rules","len","length","last","i","e","render","findRenderer","fieldName","defaultStaticRenderer","value","String","GlobalConfig","get","fieldContext","path","actualType","formConfig","renderStatic","typeName","reset","replaceRenderers","DEFAULT_RENDERERS","DEFAULT_STATIC_RENDERERS","register","newRule","unshift","newRenderers","registerLabelLookup","func","lookupLabel","registerNoneText","txt","none"],"mappings":";;;;;QAqHgBA,qB,GAAAA,qB;;AArHhB;;;;AAEA;;;;AACA;;;;AAEA;;;;AAEA,IAAIC,kBAAJ;AACA,IAAIC,cAAc,IAAlB;AACA,IAAIC,wBAAJ;;AAEA,IAAIC,WAAW,KAAf;;AAEA;;;;;;;;;;;AAWA,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,WAA3B,EAAwCC,WAAxC,EAAqDC,gBAArD,EAAuEC,WAAvE,EACA;AAAA,QACYC,IADZ,GAC4CL,IAD5C,CACYK,IADZ;AAAA,QACkBC,SADlB,GAC4CN,IAD5C,CACkBM,SADlB;AAAA,QAC6BC,IAD7B,GAC4CP,IAD5C,CAC6BO,IAD7B;AAAA,QACmCC,IADnC,GAC4CR,IAD5C,CACmCQ,IADnC;;;AAGI,WACKH,SAASI,SAAT,IAAsBJ,SAASJ,WAAhC,IACCM,SAASE,SAAT,IAAsBF,SAASL,WADhC,IAECI,cAAcG,SAAd,IAA2BH,cAAcH,gBAF1C,IAGCK,SAASC,SAAT,IAAsBD,SAASJ,WAJpC;AAMH;;AAED,SAASM,YAAT,CAAsBV,IAAtB,EAA4BW,KAA5B,EACA;AAAA,QACYN,IADZ,GAC4CL,IAD5C,CACYK,IADZ;AAAA,QACkBE,IADlB,GAC4CP,IAD5C,CACkBO,IADlB;AAAA,QACwBD,SADxB,GAC4CN,IAD5C,CACwBM,SADxB;AAAA,QACmCE,IADnC,GAC4CR,IAD5C,CACmCQ,IADnC;;;AAGI,QAAIH,SAASI,SAAT,IAAsBF,SAASE,SAA/B,IAA4CH,cAAcG,SAA1D,IAAuED,SAASC,SAApF,EACA;AACI,cAAM,IAAIG,KAAJ,CAAU,oEAAoEC,KAAKC,SAAL,CAAed,IAAf,CAApE,GAA2F,YAA3F,GAA0GW,KAA1G,GAAkH,IAA5H,CAAN;AACH;AACJ;;AAED;;;;;;;AAOA,SAASI,OAAT,CAAiBC,KAAjB,EAAwBC,KAAxB,EACA;AAAA,QACkBC,KADlB,GAC6EF,KAD7E,CACYX,IADZ;AAAA,QAC+Bc,KAD/B,GAC6EH,KAD7E,CACyBT,IADzB;AAAA,QACiDa,UADjD,GAC6EJ,KAD7E,CACsCV,SADtC;AAAA,QACmEe,KADnE,GAC6EL,KAD7E,CAC6DR,IAD7D;AAAA,QAEkBc,KAFlB,GAE6EL,KAF7E,CAEYZ,IAFZ;AAAA,QAE+BkB,KAF/B,GAE6EN,KAF7E,CAEyBV,IAFzB;AAAA,QAEiDiB,UAFjD,GAE6EP,KAF7E,CAEsCX,SAFtC;AAAA,QAEmEmB,KAFnE,GAE6ER,KAF7E,CAE6DT,IAF7D;;AAGI,WAAOU,UAAUI,KAAV,IAAmBH,UAAUI,KAA7B,IAAsCH,eAAeI,UAArD,IAAmEH,UAAUI,KAApF;AACH;;AAED,SAASC,aAAT,CAAuBC,KAAvB,EACA;AACI,QAAMC,MAAMD,MAAME,MAAlB;AACA,QAAI,CAACF,KAAD,IAAU,CAACC,GAAf,EACA;AACI,cAAM,IAAIhB,KAAJ,CAAU,mEAAV,CAAN;AACH;;AAED,QAAMkB,OAAOF,MAAM,CAAnB;AACA,SAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAIH,GAApB,EAAyBG,GAAzB,EACA;AACI,YAAMC,IAAIL,MAAMI,CAAN,CAAV;;AAEA,YAAIA,MAAMD,IAAV,EACA;AACI,gBAAIE,EAAEhC,IAAN,EACA;AACI,sBAAM,IAAIY,KAAJ,CAAU,uEAAV,CAAN;AACH;AACJ,SAND,MAQA;AACI,gBAAI,CAACoB,EAAEhC,IAAP,EACA;AACI,sBAAM,IAAIY,KAAJ,CAAU,uDAAuDmB,CAAvD,GAA2D,MAA3D,GAAoEF,MAApE,GAA6E,cAAvF,CAAN;AACH;AACDnB,yBAAasB,EAAEhC,IAAf,EAAqB+B,CAArB;AACH;;AAED,YAAI,OAAOC,EAAEC,MAAT,KAAoB,UAAxB,EACA;AACI,kBAAM,IAAIrB,KAAJ,CAAU,gDAAgDmB,CAAhD,GAAoD,MAApD,GAA6DF,MAAvE,CAAN;AACH;AACJ;AACJ;;AAED,SAASK,YAAT,CAAsB7B,IAAtB,EAA4BE,IAA5B,EAAkCD,SAAlC,EAA6C6B,SAA7C,EACA;AACI,QAAML,OAAOnC,UAAUkC,MAAV,GAAmB,CAAhC;AACA,SAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAID,IAApB,EAA0BC,GAA1B,EACA;AAAA,2BAC6BpC,UAAUoC,CAAV,CAD7B;AAAA,YACY/B,IADZ,gBACYA,IADZ;AAAA,YACkBiC,MADlB,gBACkBA,MADlB;;;AAGI,YAAIlC,YAAYC,IAAZ,EAAkBK,IAAlB,EAAwBE,IAAxB,EAA8BD,SAA9B,EAAyC6B,SAAzC,CAAJ,EACA;AACI;AACA,mBAAOF,MAAP;AACH;AACJ;AACD,WAAOtC,UAAUmC,IAAV,EAAgBG,MAAvB;AACH;;AAED,SAASG,qBAAT,CAA+BC,KAA/B,EACA;AACI,WAAOC,OAAOD,KAAP,CAAP;AACH;;AAEM,SAAS3C,qBAAT,CAA+Bc,IAA/B,EACP;AACI,WAAOX,gBAAgBW,IAAhB,KAAyB4B,qBAAhC;AACH;;AAED;;;;;AAKA,IAAMG,eAAe;;AAEjB;;;;;AAKAC,SAAK,aAASC,YAAT,EACL;AAAA,YACYnC,SADZ,GACgCmC,YADhC,CACYnC,SADZ;AAAA,YACuBoC,IADvB,GACgCD,YADhC,CACuBC,IADvB;;;AAGI,YAAMC,aAAa,gCAAcrC,SAAd,CAAnB;;AAEA;;AAEA,YAAK,CAAC,+BAAaqC,UAAb,CAAD,IAA6B,CAAC,6BAAWA,UAAX,CAAnC,EACA;AACI,kBAAM,IAAI/B,KAAJ,CAAU,qBAAoB6B,aAAaG,UAAb,CAAwBvC,IAA5C,GAAmD,GAAnD,GAAyDqC,IAAzD,GAAgE,yBAAhE,GAA4F7B,KAAKC,SAAL,CAAe6B,UAAf,CAAtG,CAAN;AACH;;AAED,eAAOT,aAAcO,aAAaG,UAAb,CAAwBvC,IAAtC,EAA4CsC,WAAWpC,IAAvD,EAA6DoC,WAAWnC,IAAxE,EAA8EkC,KAAKA,KAAKb,MAAL,GAAc,CAAnB,CAA9E,CAAP;AACH,KArBgB;;AAuBjBgB,kBAAc,sBAASC,QAAT,EAAmBT,KAAnB,EACd;AACI,eAAO3C,sBAAsBoD,QAAtB,EAAgCT,KAAhC,CAAP;AACH,KA1BgB;;AA4BjBU,WAAO,iBAAY;;AAEfR,qBAAaS,gBAAb,CACIC,0BADJ;;AAIApD,0BAAkBqD,gCAAlB;AACH,KAnCgB;AAoCjBC,YApCiB,oBAoCRC,OApCQ,EAqCjB;AACI;AACA,YAAI,CAACA,QAAQpD,IAAb,EACA;AACI;AACA,gBAAM8B,OAAOnC,UAAUkC,MAAV,GAAmB,CAAhC;AACAlC,sBAAUmC,IAAV,IAAkBsB,OAAlB;AACH,SALD,MAOA;AACI;AACA,iBAAK,IAAIrB,IAAI,CAAb,EAAgBA,IAAIpC,UAAUkC,MAA9B,EAAsCE,GAAtC,EACA;AACI,oBAAMC,IAAIrC,UAAUoC,CAAV,CAAV;;AAEA,oBAAIhB,QAAQiB,EAAEhC,IAAV,EAAgBoD,QAAQpD,IAAxB,CAAJ,EACA;AACIL,8BAAUoC,CAAV,IAAeqB,OAAf;AACA;AACH;AACJ;;AAED;AACAzD,sBAAU0D,OAAV,CAAkBD,OAAlB;AACH;AACJ,KA9DgB;;;AAgEjBJ,sBAAkB,0BAASM,YAAT,EAClB;AACI5B,sBAAc4B,YAAd;AACA3D,oBAAY2D,YAAZ;AACH,KApEgB;;AAsEjBC,yBAAqB,6BAASC,IAAT,EACrB;AACI5D,sBAAc4D,IAAd;AACH,KAzEgB;;AA2EjBC,iBAAa,qBAASb,UAAT,EAAqBpC,IAArB,EAA2B;AACpC,eAAOZ,cAAcA,YAAYgD,UAAZ,EAAwBpC,IAAxB,CAAd,GAA8CA,IAArD;AACH,KA7EgB;;AA+EjBkD,sBAAkB,0BAASC,GAAT,EAClB;AACI7D,mBAAW6D,GAAX;AACH,KAlFgB;;AAoFjBC,UAAM,gBAAY;AACd,eAAO9D,QAAP;AACH;AAtFgB,CAArB;;AA0FAyC,aAAaQ,KAAb;;kBAEeR,Y","file":"GlobalConfig.js","sourcesContent":["import React from \"react\"\n\nimport DEFAULT_RENDERERS from \"./default-renderers\"\nimport DEFAULT_STATIC_RENDERERS from \"./default-static-renderers\"\n\nimport { isEnumType, isScalarType, unwrapNonNull } from \"./InputSchema\";\n\nlet renderers;\nlet labelLookup = null;\nlet staticRenderers;\n\nlet noneText = \"---\";\n\n/**\n * Checks if the given rule matches the given current fields. If a field exists in the rule it must be equal\n * to the current field value\n *\n * @param {Object} rule             rule object\n * @param {String} currentType          current \"type\" field, referencing a domain type  \n * @param {String} currentKind          current \"kind\" field (\"ENUM\" OR \"SCALAR)\n * @param {String} currentFieldType     current scalar \"fieldType\" field (e.g. \"String\")\n * @param {String} currentName          current \"name\" of the field \n * @returns {boolean}\n */\nfunction matchesRule(rule, currentType, currentKind, currentFieldType, currentName)\n{\n    const { type, fieldType, kind, name } = rule;\n\n    return (\n        (type !== undefined && type === currentType) ||\n        (kind !== undefined && kind === currentKind) ||\n        (fieldType !== undefined && fieldType === currentFieldType) ||\n        (name !== undefined && name === currentName)\n    );\n}\n\nfunction validateRule(rule, index)\n{\n    const { type, kind, fieldType, name } = rule;\n\n    if (type === undefined && kind === undefined && fieldType === undefined && name === undefined)\n    {\n        throw new Error(\"Rule must define at least one of type, kind fieldType or name: \" + JSON.stringify(rule) + \" (index = \" + index + \" )\");\n    }\n}\n\n/**\n * Returns true if the given two rules are equal, produce the same matches.\n *\n * @param ruleA     Rule a\n * @param ruleB     Rule b\n * @returns {boolean}   true if equal\n */\nfunction isEqual(ruleA, ruleB)\n{\n    const { type: typeA, kind: kindA, fieldType: fieldTypeA, name: nameA } = ruleA;\n    const { type: typeB, kind: kindB, fieldType: fieldTypeB, name: nameB } = ruleB;\n    return typeA === typeB && kindA === kindB && fieldTypeA === fieldTypeB && nameA === nameB;\n}\n\nfunction validateRules(rules)\n{\n    const len = rules.length;\n    if (!rules || !len)\n    {\n        throw new Error(\"Rules must be a list of renderer entry objects { rule, renderer }\")\n    }\n\n    const last = len - 1;\n    for (let i = 0; i < len; i++)\n    {\n        const e = rules[i];\n\n        if (i === last)\n        {\n            if (e.rule)\n            {\n                throw new Error(\"The last rule entry is the default entry and must have a rule = false\");\n            }\n        }\n        else\n        {\n            if (!e.rule)\n            {\n                throw new Error(\"Only the last rule entry can have no rule: Entry #\" + i + \" of \" + length + \" has no rule\" );\n            }\n            validateRule(e.rule, i);\n        }\n\n        if (typeof e.render !== \"function\")\n        {\n            throw new Error(\"render property is not a function:  Entry #\" + i + \" of \" + length );\n        }\n    }\n}\n\nfunction findRenderer(type, kind, fieldType, fieldName)\n{\n    const last = renderers.length - 1;\n    for (let i = 0; i < last; i++)\n    {\n        const { rule, render } = renderers[i];\n\n        if (matchesRule(rule, type, kind, fieldType, fieldName))\n        {\n            //console.log(renderers[i], \"matches\", {type, fieldType, fieldName});\n            return render;\n        }\n    }\n    return renderers[last].render;\n}\n\nfunction defaultStaticRenderer(value)\n{\n    return String(value);\n}\n\nexport function resolveStaticRenderer(name)\n{\n    return staticRenderers[name] || defaultStaticRenderer;\n}\n\n/**\n * Global static configuration object for field renderers, static type renderers and other global configuration settings.\n *\n * @type {{get: (function(*)), renderStatic: (function(*=, *=): *), reset: GlobalConfig.reset, register(*=): undefined, replaceRenderers: GlobalConfig.replaceRenderers, registerLabelLookup: GlobalConfig.registerLabelLookup, lookupLabel: (function(*=, *=): *), registerNoneText: GlobalConfig.registerNoneText, none: (function(): string)}}\n */\nconst GlobalConfig = {\n\n    /**\n     * Resolves the render method for the given context\n     *\n     * @param fieldContext              field context object\n     */\n    get: function(fieldContext)\n    {\n        const { fieldType, path } = fieldContext;\n\n        const actualType = unwrapNonNull(fieldType);\n\n        //console.log(\"GET RENDERER\", fieldType, path, \"=>\", actualType);\n\n        if ( !isScalarType(actualType) && !isEnumType(actualType))\n        {\n            throw new Error(\"Field  type for \"+ fieldContext.formConfig.type + \".\" + path + \" is no scalar or enum: \" + JSON.stringify(actualType));\n        }\n\n        return findRenderer( fieldContext.formConfig.type, actualType.kind, actualType.name, path[path.length - 1]);\n    },\n\n    renderStatic: function(typeName, value)\n    {\n        return resolveStaticRenderer(typeName)(value);\n    },\n\n    reset: function () {\n\n        GlobalConfig.replaceRenderers(\n            DEFAULT_RENDERERS\n        );\n\n        staticRenderers = DEFAULT_STATIC_RENDERERS;\n    },\n    register(newRule)\n    {\n        // if we have no rule\n        if (!newRule.rule)\n        {\n            // we replace the last entry because we can only have one entry without rule / being the default renderer\n            const last = renderers.length - 1;\n            renderers[last] = newRule;\n        }\n        else\n        {\n            // replace renderer if we find the exact same rule\n            for (let i = 0; i < renderers.length; i++)\n            {\n                const e = renderers[i];\n\n                if (isEqual(e.rule, newRule.rule))\n                {\n                    renderers[i] = newRule;\n                    return;\n                }\n            }\n\n            // otherwise we move it to the first position in the list / to being the highest priority rule\n            renderers.unshift(newRule);\n        }\n    },\n\n    replaceRenderers: function(newRenderers)\n    {\n        validateRules(newRenderers);\n        renderers = newRenderers;\n    },\n\n    registerLabelLookup: function(func)\n    {\n        labelLookup = func;\n    },\n\n    lookupLabel: function(formConfig, name) {\n        return labelLookup ? labelLookup(formConfig, name) : name;\n    },\n\n    registerNoneText: function(txt)\n    {\n        noneText = txt;\n    },\n\n    none: function () {\n        return noneText;\n    }\n};\n\n\nGlobalConfig.reset();\n\nexport default GlobalConfig;\n"]}