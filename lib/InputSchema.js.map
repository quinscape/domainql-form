{"version":3,"sources":["../src/InputSchema.js"],"names":["findNamed","resetConverter","registerCustomConverter","isInputType","isScalarType","isListType","isNonNull","unwrapNonNull","isEnumType","PLAN_SCALAR_LIST","__scalar_list","PLAN_COMPLEX_LIST","__complex_list","PLAN_INPUT_OBJECT","__input_object","NO_ERRORS","array","name","i","length","type","converter","DEFAULT_CONVERTERS","validate","scalarToValue","valueToScalar","kind","ofType","resolve","inputSchema","current","path","pos","len","prop","next","getType","Error","JSON","stringify","found","inputFields","handlerFn","typeName","handlerName","entry","fn","checkNonNull","value","checkNonNullBool","getValidationPlan","existing","validationPlan","inputTypeDef","plan","field","typeIsNonNull","actualType","isScalar","push","inputTypePlan","elementType","elementPlan","fieldType","convertValue","toScalar","result","InputSchema","convertInput","Array","j","baseTypeDef","out","executeValidationPlan","values","errors","fnOrArray","fieldValue","error","err","slice","schema","types","currentType","scalarType"],"mappings":"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","file":"InputSchema.js","sourcesContent":["import toPath from \"lodash.topath\"\n\nimport DEFAULT_CONVERTERS from \"./default-converters\"\n\nconst PLAN_SCALAR_LIST = { __scalar_list : true };\nconst PLAN_COMPLEX_LIST = { __complex_list : true };\nconst PLAN_INPUT_OBJECT = { __input_object : true };\n\nconst NO_ERRORS = {};\n\nexport function findNamed(array, name)\n{\n    for (let i = 0; i < array.length; i++)\n    {\n        const type = array[i];\n        if (type.name === name)\n        {\n            return type;\n        }\n    }\n\n    return null;\n}\n\nlet converter;\n\nexport function resetConverter()\n{\n    converter = DEFAULT_CONVERTERS;\n}\n\n/**\n * Register new scalar converter / validator\n *\n * @param {String} type                 type name\n * @param {function} validate           validates the given string value and returns an error message if the value is invalid\n * @param {function} scalarToValue      converts the scalar value to a user-editable string representation\n * @param {function} valueToScalar      converts the string representation back to a scalar value\n */\nexport function registerCustomConverter(type, validate, scalarToValue, valueToScalar)\n{\n    converter[type] = {\n        validate,\n        scalarToValue,\n        valueToScalar\n    };\n}\n\nresetConverter();\n\nexport function isInputType(type)\n{\n    return type && type.kind === \"INPUT_OBJECT\"\n}\n\nexport function isScalarType(type)\n{\n    return type && type.kind === \"SCALAR\"\n}\n\nexport function isListType(type)\n{\n    return type && type.kind === \"LIST\"\n}\n\nexport function isNonNull(type)\n{\n    return type && type.kind === \"NON_NULL\"\n}\n\n\nexport function unwrapNonNull(type)\n{\n    if (isNonNull(type))\n    {\n        return type.ofType;\n    }\n    return type;\n}\n\n\nfunction resolve(inputSchema, current, path, pos)\n{\n    const len = path.length;\n\n    current = unwrapNonNull(current);\n\n    const prop = path[pos];\n    const next = pos + 1;\n\n    if (isListType(current))\n    {\n        current = inputSchema.getType(current.ofType.name);\n\n        if (next === len)\n        {\n            return current;\n        }\n\n        return resolve(inputSchema, current, path, next);\n    }\n    else if (!isInputType(current))\n    {\n        throw new Error(\"Invalid type '\" + current.name + \"': \" + JSON.stringify(current));\n    }\n\n    const found = findNamed(current.inputFields, prop);\n\n    if (!found)\n    {\n        throw new Error(\"Could not find '\" + prop + \"' ( path = \" + path + \", pos = \" + pos + \") in \" + JSON.stringify(current))\n    }\n\n    current = found.type;\n\n    if (!current)\n    {\n        throw new Error(\"Could not find field '\" + prop + \"' in type '\" + current.name + \"'\");\n    }\n\n    if (next === len)\n    {\n        return current;\n    }\n\n    return resolve(inputSchema, current, path, next);\n}\n\nfunction handlerFn(typeName, handlerName)\n{\n    const entry = converter[typeName];\n    if (entry === false)\n    {\n        return null;\n    }\n    else if (!entry)\n    {\n        throw new Error(\"Unknown scalar '\" + typeName + \"'\");\n    }\n\n    const fn = entry[handlerName];\n\n    if (fn === false)\n    {\n        return null;\n    }\n    else if (!fn)\n    {\n        throw new Error(\"Undefined handler '\" + handlerName + \"' on \" + typeName);\n    }\n    return fn;\n}\n\nfunction checkNonNull(value)\n{\n    return !value ? \"$FIELD required\" : null\n}\n\nfunction checkNonNullBool(value)\n{\n    return value !== true && value !== false ? \"$FIELD required\" : null\n}\n\nfunction getValidationPlan(inputSchema, typeName)\n{\n    const existing = inputSchema.validationPlan[typeName];\n    if (existing)\n    {\n        return existing;\n    }\n\n    const inputTypeDef = inputSchema.getType(typeName);\n\n    if (!isInputType(inputTypeDef))\n    {\n        throw new Error(\"'\" + typeName + \"' is not a known input type\");\n    }\n\n    const { inputFields } = inputTypeDef;\n\n\n    const plan = [];\n\n    for (let i = 0; i < inputFields.length; i++)\n    {\n        const field = inputFields[i];\n        const { name, type} = field;\n\n        const typeIsNonNull = isNonNull(type);\n        const actualType = unwrapNonNull(type);\n        const isScalar = isScalarType(actualType);\n\n        if (typeIsNonNull)\n        {\n            if (isScalar && actualType.name === \"Boolean\")\n            {\n                plan.push(name, checkNonNullBool);\n            }\n            else\n            {\n                plan.push(name, checkNonNull);\n            }\n        }\n\n        if (isScalar)\n        {\n            const fn = handlerFn(actualType.name, \"validate\");\n\n            //console.log(\"Scalar type \", actualType, \": validator = \", fn);\n\n            if (fn)\n            {\n                plan.push(name, fn);\n            }\n        }\n        else if (isInputType(actualType))\n        {\n            const inputTypePlan = getValidationPlan(inputSchema, actualType.name);\n            if (inputTypePlan.length)\n            {\n                plan.push(name, [ PLAN_INPUT_OBJECT, ... inputTypePlan])\n            }\n        }\n        else if (isListType(actualType))\n        {\n            const elementType = inputSchema.getType(actualType.ofType.name);\n\n            if (isScalarType(elementType))\n            {\n                const fn = handlerFn(elementType.name, \"validate\");\n\n                if (fn)\n                {\n                    plan.push(name, [ PLAN_SCALAR_LIST, fn])\n                }\n            }\n            else\n            {\n                const elementPlan = getValidationPlan(inputSchema, elementType.name);\n                if (elementPlan.length)\n                {\n                    plan.push(name, [ PLAN_COMPLEX_LIST, ... elementPlan])\n                    plan.push(name, elementPlan)\n                }\n            }\n        }\n    }\n\n    //console.log(\"Validation plan for \", typeName, \"is: \", plan);\n\n    inputSchema.validationPlan[typeName] = plan;\n\n    return plan;\n}\n\nexport function isEnumType(fieldType)\n{\n    return fieldType && fieldType.kind === \"ENUM\";\n}\n\nfunction convertValue(inputSchema, fieldType, value, toScalar)\n{\n    fieldType = unwrapNonNull(fieldType);\n\n    if (isScalarType(fieldType))\n    {\n        let result;\n        if (toScalar)\n        {\n            result = InputSchema.valueToScalar(fieldType.name, value);\n        }\n        else\n        {\n            result = InputSchema.scalarToValue(fieldType.name, value);\n\n            if (fieldType.name !== \"Boolean\")\n            {\n                result = result || \"\";\n            }\n        }\n\n        //console.log(value, \"( type\", fieldType, \") ==\", toScalar ? \"toScalar\" : \"fromScalar\" , \"=> \", result, typeof result);\n\n        return result;\n    }\n    else if (isInputType(fieldType))\n    {\n        if (!value)\n        {\n            return toScalar ? null : {};\n        }\n\n        return convertInput(inputSchema, inputSchema.getType(fieldType.name), value, toScalar);\n    }\n    else if (isListType(fieldType))\n    {\n        if (!value)\n        {\n            return toScalar ? null : [];\n        }\n\n        const array = new Array(value.length);\n\n        for (let j = 0; j < value.length; j++)\n        {\n            array[j] = convertValue(inputSchema, inputSchema.getType(fieldType.ofType.name), value[j], toScalar);\n        }\n        return array;\n    }\n    else if (isEnumType(fieldType))\n    {\n        return value;\n    }\n    else\n    {\n        throw new Error(\"Unhandled field type : \" + JSON.stringify(fieldType));\n    }\n\n}\n\nfunction convertInput(inputSchema, baseTypeDef, value, toScalar)\n{\n    const { inputFields } = baseTypeDef;\n\n    const out = {};\n\n    for (let i = 0; i < inputFields.length; i++)\n    {\n        const field = inputFields[i];\n        const name = field.name;\n\n        out[name] = convertValue(inputSchema, field.type, value[name], toScalar);\n    }\n    return out;\n}\n\nfunction executeValidationPlan(values, validationPlan)\n{\n    if (validationPlan[0] === PLAN_SCALAR_LIST)\n    {\n        const result = validationPlan[1](values);\n\n        //console.log(\"Scalar List elem \", values, \" => \", result);\n\n        return result;\n    }\n\n    let errors = null;\n\n    for (let i = 0; i < validationPlan.length; i+= 2)\n    {\n        const name = validationPlan[i];\n        const fnOrArray = validationPlan[i + 1];\n\n        const fieldValue = values[name];\n        if (typeof fnOrArray === \"function\")\n        {\n            const error = fnOrArray(fieldValue);\n\n            //console.log(\"field \", name, \": \", fieldValue, \" => \", error);\n            if (error)\n            {\n                errors = errors || {};\n                errors[name] = error;\n            }\n        }\n        else\n        {\n            if (fnOrArray[0] === PLAN_COMPLEX_LIST)\n            {\n                if (fieldValue)\n                {\n                    let array = null;\n\n                    for (let j = 0; j < fieldValue.length; j++)\n                    {\n                        const err = executeValidationPlan(fieldValue[j], fnOrArray.slice(1));\n                        if (err)\n                        {\n                            array = array || new Array(fieldValue.length);\n                            array[j] = err;\n                        }\n                    }\n\n                    if (array)\n                    {\n                        errors = errors || {};\n                        errors[name] = array;\n                    }\n                }\n            }\n            else if (fnOrArray[0] === PLAN_INPUT_OBJECT)\n            {\n                if (fieldValue)\n                {\n                    const err = executeValidationPlan(fieldValue, fnOrArray.slice(1));\n                    if (err)\n                    {\n                        errors = errors || {};\n                        errors[name] = err;\n                    }\n                }\n            }\n        }\n    }\n    return errors;\n}\n\nclass InputSchema\n{\n    constructor(schema)\n    {\n        const { types } = schema;\n\n        if (!types || typeof types.length !== \"number\")\n        {\n            throw new Error(\"Given Schema object has no 'types' array property\");\n        }\n\n        this.schema = schema;\n        this.validationPlan = {};\n    }\n\n    /**\n     * Resolves a complex type definition\n     *\n     * @param typeName      name of type\n     */\n    getType(typeName)\n    {\n        const { types } = this.schema;\n\n        return findNamed(types, typeName);\n    }\n\n    /**\n     * Resolves the type of a name expression\n     *\n     * @param typeName      base type\n     * @param name          name expression (e.g. 'name', 'values[0]', 'address.city')\n     */\n    resolveType(typeName, name)\n    {\n        const path = typeof name === \"string\" ? toPath(name) : name;\n\n        const currentType = this.getType(typeName);\n\n        return resolve(this, currentType, path, 0);\n    }\n\n    static validate(scalarType, value)\n    {\n        const fn = handlerFn(scalarType, \"validate\");\n        return fn ? fn(value) : \"\"\n    }\n\n    static scalarToValue(scalarType, value)\n    {\n        const fn = handlerFn(scalarType, \"scalarToValue\");\n        return fn ? fn(value) : value\n    }\n\n    static valueToScalar(scalarType, value)\n    {\n        const fn = handlerFn(scalarType, \"valueToScalar\");\n        return fn ? fn(value) : value\n    }\n\n    toValues(typeName, value)\n    {\n        const baseTypeDef = this.getType(typeName);\n        if (!isInputType(baseTypeDef))\n        {\n            throw new Error(typeName + \" is not a known input type: \" + JSON.stringify(baseTypeDef))\n        }\n\n        return convertInput(this, baseTypeDef, value, false);\n    }\n\n    fromValues(typeName, value)\n    {\n        const baseTypeDef = this.getType(typeName);\n        if (!isInputType(baseTypeDef))\n        {\n            throw new Error(typeName + \" is not a known input type: \" + JSON.stringify(baseTypeDef))\n        }\n\n        return convertInput(this, baseTypeDef, value, true);\n    }\n\n    getTypes()\n    {\n        return this.schema.types;\n    }\n\n    validate(type, values)\n    {\n        const validationPlan = getValidationPlan(this, type);\n\n        const errors = executeValidationPlan(values, validationPlan);\n\n        return errors || NO_ERRORS;\n    }\n\n}\n\nexport default InputSchema\n"]}