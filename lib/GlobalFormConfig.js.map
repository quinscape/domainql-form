{"version":3,"sources":["../src/GlobalFormConfig.js"],"names":["resolveStaticRenderer","renderers","labelLookup","staticRenderers","noneText","matchesRule","rule","currentType","currentKind","currentFieldType","currentName","type","fieldType","kind","name","undefined","validateRule","index","Error","JSON","stringify","isEqual","ruleA","ruleB","typeA","kindA","fieldTypeA","nameA","typeB","kindB","fieldTypeB","nameB","validateRules","rules","len","length","last","i","e","render","findRenderer","fieldName","defaultStaticRenderer","value","String","GlobalFormConfig","get","fieldContext","path","actualType","formConfig","formContext","renderStatic","typeName","reset","replaceRenderers","DEFAULT_RENDERERS","DEFAULT_STATIC_RENDERERS","register","newEntry","unshift","newRenderers","registerLabelLookup","func","lookupLabel","registerNoneText","txt","none"],"mappings":"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","file":"GlobalFormConfig.js","sourcesContent":["import React from \"react\"\n\nimport DEFAULT_RENDERERS from \"./default-renderers\"\nimport DEFAULT_STATIC_RENDERERS from \"./default-static-renderers\"\n\nimport { isEnumType, isScalarType, unwrapNonNull } from \"./InputSchema\";\n\nlet renderers;\nlet labelLookup = null;\nlet staticRenderers;\n\nlet noneText = \"---\";\n\n/**\n * Checks if the given rule matches the given current fields. If a field exists in the rule it must be equal\n * to the current field value\n *\n * @param {Object} rule             rule object\n * @param {String} currentType          current \"type\" field, referencing a domain type  \n * @param {String} currentKind          current \"kind\" field (\"ENUM\" OR \"SCALAR)\n * @param {String} currentFieldType     current scalar \"fieldType\" field (e.g. \"String\")\n * @param {String} currentName          current \"name\" of the field \n * @returns {boolean}\n */\nfunction matchesRule(rule, currentType, currentKind, currentFieldType, currentName)\n{\n    const { type, fieldType, kind, name } = rule;\n\n    return (\n        (type !== undefined && type === currentType) ||\n        (kind !== undefined && kind === currentKind) ||\n        (fieldType !== undefined && fieldType === currentFieldType) ||\n        (name !== undefined && name === currentName)\n    );\n}\n\nfunction validateRule(rule, index)\n{\n    const { type, kind, fieldType, name } = rule;\n\n    if (type === undefined && kind === undefined && fieldType === undefined && name === undefined)\n    {\n        throw new Error(\"Rule must define at least one of type, kind fieldType or name: \" + JSON.stringify(rule) + \" (index = \" + index + \" )\");\n    }\n}\n\n/**\n * Returns true if the given two rules are equal, produce the same matches.\n *\n * @param ruleA     Rule a\n * @param ruleB     Rule b\n * @returns {boolean}   true if equal\n */\nfunction isEqual(ruleA, ruleB)\n{\n    const { type: typeA, kind: kindA, fieldType: fieldTypeA, name: nameA } = ruleA;\n    const { type: typeB, kind: kindB, fieldType: fieldTypeB, name: nameB } = ruleB;\n    return typeA === typeB && kindA === kindB && fieldTypeA === fieldTypeB && nameA === nameB;\n}\n\nfunction validateRules(rules)\n{\n    const len = rules.length;\n    if (!rules || !len)\n    {\n        throw new Error(\"Rules must be a list of renderer entry objects { rule, renderer }\")\n    }\n\n    const last = len - 1;\n    for (let i = 0; i < len; i++)\n    {\n        const e = rules[i];\n\n        if (i === last)\n        {\n            if (e.rule)\n            {\n                throw new Error(\"The last rule entry is the default entry and must have a rule = false\");\n            }\n        }\n        else\n        {\n            if (!e.rule)\n            {\n                throw new Error(\"Only the last rule entry can have no rule: Entry #\" + i + \" of \" + length + \" has no rule\" );\n            }\n            validateRule(e.rule, i);\n        }\n\n        if (typeof e.render !== \"function\")\n        {\n            throw new Error(\"render property is not a function:  Entry #\" + i + \" of \" + length );\n        }\n    }\n}\n\nfunction findRenderer(type, kind, fieldType, fieldName)\n{\n    const last = renderers.length - 1;\n    for (let i = 0; i < last; i++)\n    {\n        const { rule, render } = renderers[i];\n\n        if (matchesRule(rule, type, kind, fieldType, fieldName))\n        {\n            //console.log(renderers[i], \"matches\", {type, fieldType, fieldName});\n            return render;\n        }\n    }\n    return renderers[last].render;\n}\n\nfunction defaultStaticRenderer(value)\n{\n    return String(value);\n}\n\nexport function resolveStaticRenderer(name)\n{\n    return staticRenderers[name] || defaultStaticRenderer;\n}\n\n/**\n *\n * @type {{get: GlobalFormConfig.get, reset: GlobalFormConfig.reset, register(*=): void, replaceRenderers: GlobalFormConfig.replaceRenderers}}\n */\nconst GlobalFormConfig = {\n\n    /**\n     * Resolves the render method for the given context\n     *\n     * @param fieldContext              field context object\n     * @param name                      field name / path\n     */\n    get: function(fieldContext)\n    {\n        const { fieldType, path } = fieldContext;\n\n        const actualType = unwrapNonNull(fieldType);\n\n        //console.log(\"GET RENDERER\", fieldType, path, \"=>\", actualType);\n\n        if ( !isScalarType(actualType) && !isEnumType(actualType))\n        {\n            throw new Error(\"Field  type for \"+ fieldContext.formConfig.formContext.type + \".\" + path + \" is no scalar or enum: \" + JSON.stringify(actualType));\n        }\n\n        return findRenderer( fieldContext.formConfig.formContext.type, actualType.kind, actualType.name, path[path.length - 1]);\n    },\n\n    renderStatic: function(typeName, value)\n    {\n        return resolveStaticRenderer(typeName)(value);\n    },\n\n    reset: function () {\n\n        GlobalFormConfig.replaceRenderers(\n            DEFAULT_RENDERERS\n        );\n\n        staticRenderers = DEFAULT_STATIC_RENDERERS;\n    },\n    register(newEntry)\n    {\n        // if we have no rule\n        if (!newEntry.rule)\n        {\n            // we replace the last entry because we can only have one entry without rule / being the default renderer\n            const last = renderers.length - 1;\n            renderers[last] = newEntry;\n        }\n        else\n        {\n            // replace renderer if we find the exact same rule\n            for (let i = 0; i < renderers.length; i++)\n            {\n                const e = renderers[i];\n\n                if (isEqual(e.rule, newEntry.rule))\n                {\n                    renderers[i] = newEntry;\n                    return;\n                }\n            }\n\n            // otherwise we move it to the first position in the list / to being the highest priority rule\n            renderers.unshift(newEntry);\n        }\n    },\n\n    replaceRenderers: function(newRenderers)\n    {\n        validateRules(newRenderers);\n        renderers = newRenderers;\n    },\n\n    registerLabelLookup: function(func)\n    {\n        labelLookup = func;\n    },\n\n    lookupLabel: function(formConfig, name) {\n        return labelLookup ? labelLookup(formConfig, name) : name;\n    },\n\n    registerNoneText: function(txt)\n    {\n        noneText = txt;\n    },\n\n    none: function () {\n        return noneText;\n    }\n};\n\n\nGlobalFormConfig.reset();\n\n/**\n * Context object given to the renderer functions.\n * \n * @typedef {object} FieldRenderContext\n *\n * @property {string} name              path within the form object (e.g. 'value' , 'address.city', 'foos[0].name')\n * @property {string} mode              Field mode 'normal', 'disabled' or 'read-only'\n * @property {string} helpText          Static help text below the field\n * @property {string} title             Field title / tooltip\n * @property {string} label             label to use, defaults to the i18n name of the field (e.g. i18n('Foo:value') )\n * @property {string} placeholder       placeholder text to show inside the input\n * @property {string} inputClass        additional classes for the input element\n * @property {string} wrapperClass      additional classes for the horizontal mode wrapper, ignored if not horizontal\n * @property {string} labelClass        additional classes for the label element\n * @property {object} formik            formik props containing form helper methods ( see https://github.com/jaredpalmer/formik#formik-props )\n * @property {object} formContext       GQLFormContext object from the parent GQLForm\n * @property {string} fieldId           Field id. This is either the id prop given to the Field or type-based auto-generated id\n\n */\nexport default GlobalFormConfig;\n\n"]}